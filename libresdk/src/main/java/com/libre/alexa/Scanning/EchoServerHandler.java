package com.libre.alexa.Scanning;import android.util.Log;import com.libre.alexa.SceneObject;import com.libre.alexa.luci.LSSDPNodeDB;import com.libre.alexa.luci.LSSDPNodes;import com.libre.alexa.luci.LUCIControl;import com.libre.alexa.netty.BusProvider;import com.libre.alexa.netty.NettyAndroidClient;import com.libre.alexa.netty.NettyClientHandler;import com.libre.alexa.util.LibreLogger;import org.jboss.netty.buffer.ChannelBuffer;import org.jboss.netty.channel.ChannelHandlerContext;import org.jboss.netty.channel.ChannelStateEvent;import org.jboss.netty.channel.ChildChannelStateEvent;import org.jboss.netty.channel.ExceptionEvent;import org.jboss.netty.channel.MessageEvent;import org.jboss.netty.channel.SimpleChannelHandler;import java.net.InetAddress;import java.net.InetSocketAddress;public class EchoServerHandler extends SimpleChannelHandler {    public ScanningHandler m_scanHandler = ScanningHandler.getInstance();    public NettyClientHandler handler;    @Override    public void childChannelClosed(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {        super.childChannelClosed(ctx, e);    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)            throws Exception {        // TODO Auto-generated method stub        //super.exceptionCaught(ctx, e);        System.out.println(" EXCEPTION CaUGHT ++ " + e.getCause().toString());        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LibreLogger.d(this, "Exception  Caught For the Ip " + address.getHostAddress() + "as" + e.getCause().getMessage());        if (LUCIControl.channelHandlerContextMap.containsKey(address.getHostAddress())) {            if (isChannelToBeRemovedFromTheChannelHandlerMap(ctx, address.getHostAddress())) {                LUCIControl.channelHandlerContextMap.get(address.getHostAddress()).getChannel().close();                LUCIControl.channelHandlerContextMap.remove(address.getHostAddress());            }        }/*        Channel ch = e.getChannel();        ch.close();*/    }    @Override    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.channelConnected(ctx, e);        InetAddress address = null;        if (e.getChannel().getRemoteAddress() instanceof InetSocketAddress) {            Log.d("LSSDP", "socket connected successfully");            address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();            LibreLogger.d(this, "Channel Connected For the Ip " + address.getHostAddress()                    +                    "for the Channel id is " + ctx.getChannel().getId());            ctx.getChannel().getConfig().setOption("child.keepAlive", true);            ctx.getChannel().getConfig().setOption("child.reuseaddress", true);            ctx.getChannel().getConfig().setOption("child.tcpNoDelay", true);            ctx.getChannel().getConfig().setOption("child.tcpNoDelay", true);            handler = new NettyClientHandler(address.getHostAddress());        } else {            Log.d("LSSDP", "socket NOT connected successfully");        }    }    @Override    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.channelDisconnected(ctx, e);        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LibreLogger.d(this, "Channel Disconnected For the Ip " + address.getHostAddress()                +                "for the Channel id is " + e.getChannel().getId());        if (LUCIControl.channelHandlerContextMap.containsKey(address.getHostAddress())) {            if (isChannelToBeRemovedFromTheChannelHandlerMap(ctx, address.getHostAddress())) {                LUCIControl.channelHandlerContextMap.get(address.getHostAddress()).getChannel().close();                LUCIControl.channelHandlerContextMap.remove(address.getHostAddress());            }        }    }    @Override    public void closeRequested(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.closeRequested(ctx, e);    }    @Override    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.channelClosed(ctx, e);        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LibreLogger.d(this, "Channel Closed For the Ip " + address.getHostAddress() +                "for the Channel id is " + e.getChannel().getId());        if (LUCIControl.channelHandlerContextMap.containsKey(address.getHostAddress())) {            if (isChannelToBeRemovedFromTheChannelHandlerMap(ctx, address.getHostAddress())) {                LUCIControl.channelHandlerContextMap.get(address.getHostAddress()).getChannel().close();                LUCIControl.channelHandlerContextMap.remove(address.getHostAddress());            }        }    }    @Override    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)            throws Exception {        // TODO Auto-generated method stub        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LUCIControl.channelHandlerContextMap.put("" + address.getHostAddress(), ctx);        LibreLogger.d(this, "Response Message Received ");        ChannelBuffer mChannelBufferMessageReceived = (ChannelBuffer) e.getMessage();        LibreLogger.d(this, "Response Message Received  +Successfull");        /// e.getChannel().close();        String mSearchMessageReceivedFromResponse = new String(mChannelBufferMessageReceived.array());        LibreLogger.d(this, "Response Received From Speaker " + e.getRemoteAddress() + "From Port Number" +                ctx.getChannel().getRemoteAddress() + " and Message is " +                mSearchMessageReceivedFromResponse);        /* We have to Store Only NOTIFY HandlerContext */        if(mSearchMessageReceivedFromResponse.contains("NOTIFY")){            LibreLogger.d(this, "Notify is updating For the IpAddress " + address.getHostAddress()                    +                    "for the Channel id is " + ctx.getChannel().getId());            ctx.getChannel().getConfig().setOption("child.keepAlive", true);            ctx.getChannel().getConfig().setOption("child.reuseaddress", true);            ctx.getChannel().getConfig().setOption("child.tcpNoDelay", true);            LUCIControl.channelHandlerContextMap.put(address.getHostAddress(), ctx);        }        LSSDPNodes node = m_scanHandler.getLSSDPNodeFromMessage(e.getRemoteAddress(), mSearchMessageReceivedFromResponse);        if(node==null)            return;        /**LatestDiscoveryChanges         * Which means we are getting notification for first time hence we should remove old one and recreate it*/        CreateOrUpdateMyNewDevice(node);       /* if (node != null&& (node.getDeviceState()!=null) && node.getIP()!=null && node.getFirstNotification() != null && node.getFirstNotification().equals("1")) {            if (LUCIControl.luciSocketMap.containsKey(node.getIP())) {                *//**closing existing NettyAndroidClient *//*                LUCIControl.luciSocketMap.get(node.getIP()).closeSocket();                LUCIControl.luciSocketMap.remove(node.getIP());                GoAndRemoveTheDevice(node);                NettyAndroidClient nettyAndroidClient = new NettyAndroidClient(node.getNodeAddress(), 7777);                LUCIControl.luciSocketMap.put(node.getIP(), nettyAndroidClient);                NetworkInterface mNetIf = com.libre.luci.Utils.getActiveNetworkInterface();                String messageStr=  com.libre.luci.Utils.getLocalV4Address(mNetIf).getHostAddress() + "," + LUCIControl.LUCI_RESP_PORT;                ArrayList<LUCIPacket> luciPackets=new ArrayList<LUCIPacket>();                LUCIPacket packet = new LUCIPacket(messageStr.getBytes(), (short) messageStr.length(), (short) 4, (byte) LSSDPCONST.LUCI_SET);                luciPackets.add(packet);                LUCIPacket packet1 = new LUCIPacket(messageStr.getBytes(), (short) messageStr.length(), (short) 3, (byte) LSSDPCONST.LUCI_SET);                luciPackets.add(packet1);                new LUCIControl(node.getIP()).SendCommand(luciPackets);            }else{                NettyAndroidClient nettyAndroidClient = new NettyAndroidClient(node.getNodeAddress(), 7777);                LUCIControl.luciSocketMap.put(node.getIP(), nettyAndroidClient);                NetworkInterface mNetIf = Utils.getActiveNetworkInterface();                String messageStr=  com.libre.luci.Utils.getLocalV4Address(mNetIf).getHostAddress() + "," + LUCIControl.LUCI_RESP_PORT;                ArrayList<LUCIPacket> luciPackets=new ArrayList<LUCIPacket>();                LUCIPacket packet = new LUCIPacket(messageStr.getBytes(), (short) messageStr.length(), (short) 4, (byte) LSSDPCONST.LUCI_SET);                luciPackets.add(packet);                LUCIPacket packet1 = new LUCIPacket(messageStr.getBytes(), (short) messageStr.length(), (short) 3, (byte) LSSDPCONST.LUCI_SET);                luciPackets.add(packet1);                new LUCIControl(node.getIP()).SendCommand(luciPackets);            }        }        if ((node!=null) && (node.getDeviceState()!=null) && (node.getIP()!=null) && (!LUCIControl.luciSocketMap.containsKey(node.getIP()))) { /// && (LUCIControl.luciSocketMap.get(node.getIP())==null)) {            LUCIControl.luciSocketMap.put(node.getIP(), NettyAndroidClient.getDummyInstance());            LibreLogger.d(this, "Socket Creating for Ip " + node.getIP() + " as a DummyInstance ");            try {                NettyAndroidClient tcpSocketSendCtr = new NettyAndroidClient(node.getNodeAddress(), 7777);                LibreLogger.d(this, "Socket Created for Ip " + node.getIP() + " Printing From NettyAndroidClient Socket  " + tcpSocketSendCtr.getRemotehost());                //if(tcpSocketSendCtr.isSocketCreated())                {                    tcpSocketSendCtr.setLastNotifiedTime(System.currentTimeMillis());                    LUCIControl.luciSocketMap.put(node.getIP(), tcpSocketSendCtr);                    *//*sending asynchronous command*//*                    new LUCIControl(node.getIP()).sendAsynchronousCommand();                }            } catch (Exception e1) {                e1.printStackTrace();                LibreLogger.d(this, "Socket creation Failed in EchoServerHandler " + node.getIP());                LUCIControl.luciSocketMap.remove(node.getIP());                Log.e("Scan_Netty", "Socket creation not required in  EchoServerHandler" + node.getIP());            }        } else {            String mIpAddress = "";            if (node != null && node.getIP() != null) {                mIpAddress=node.getIP();            }else{                mIpAddress = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress().toString();            }            LibreLogger.d(this, "Socket Creation is not required its already in Hashmap : Ip is " +mIpAddress);            if(LUCIControl.luciSocketMap.containsKey(mIpAddress)) {                NettyAndroidClient nettyAndroidClient = LUCIControl.luciSocketMap.get(mIpAddress);                nettyAndroidClient.setLastNotifiedTime(System.currentTimeMillis());                LUCIControl.luciSocketMap.put(mIpAddress, nettyAndroidClient);            *//*sending asynchronous command*//**//*            new LUCIControl(node.getIP()).deRegister();            new LUCIControl(node.getIP()).sendAsynchronousCommand();*//*                Log.e("EchoServerhandler", "Socket creation not required in  EchoServerHandler" + node.getIP()                        + "for the Device Name " + node.getFriendlyname());            }        }        if ((node!=null) && (node.getIP() !=null) && (node.getDeviceState()!=null) && (!m_scanHandler.findDupicateNode(node))) {            Log.d("KhajanPandey", "--postingNode--" + node);            BusProvider.getInstance().post(node);            m_scanHandler.lssdpNodeDB.AddtoDB(node);        }*/    }    private void CreateOrUpdateMyNewDevice(LSSDPNodes mInputNode){        if(LUCIControl.luciSocketMap.containsKey(mInputNode.getIP())){            NettyAndroidClient mExistingAndroidClient = LUCIControl.luciSocketMap.get(mInputNode.getIP());            /*Socket is Already Exists*/            if( mInputNode.getFirstNotification()!=null && mInputNode.getFirstNotification().equals("1") && (System.currentTimeMillis()-mExistingAndroidClient.getCreationTime())>5000){                LibreLogger.d(this,"In Create Or Update My New Device for the FirstNotification is 1 and CreationTimeMills's Difference is 5s for Ipaddress --> " + mInputNode.getIP() +                        "And Name of the Device is " + mInputNode.getFriendlyname() );                /**closing existing NettyAndroidClient */                LUCIControl.luciSocketMap.get(mInputNode.getIP()).closeSocket();                LUCIControl.luciSocketMap.remove(mInputNode.getIP());                /* I will remove previous Socket Information */                RemovingTheCorrespondingSceneMapFromCentralDB(mInputNode);                NettyAndroidClient nettyAndroidClient = null;                try {                    nettyAndroidClient = new NettyAndroidClient(mInputNode.getNodeAddress(), 7777);                } catch (Exception e) {                    e.printStackTrace();                }                LUCIControl.luciSocketMap.put(mInputNode.getIP(), nettyAndroidClient);                LUCIControl control = new LUCIControl(mInputNode.getIP());                control.sendAsynchronousCommandSpecificPlaces();                LSSDPNodeDB lssdpNodeDB = LSSDPNodeDB.getInstance();                LSSDPNodes theNodeBasedOnTheIpAddress = lssdpNodeDB.getTheNodeBasedOnTheIpAddress(mInputNode.getIP());                if (theNodeBasedOnTheIpAddress != null && theNodeBasedOnTheIpAddress.getgCastVerision() != null) {                    // sleep                    try {                        Thread.sleep(250);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }              /*  NetworkInterface mNetIf = com.libre.luci.Utils.getActiveNetworkInterface();                String messageStr=  com.libre.luci.Utils.getLocalV4Address(mNetIf).getHostAddress() + "," + LUCIControl.LUCI_RESP_PORT;                ArrayList<LUCIPacket> luciPackets=new ArrayList<LUCIPacket>();                LUCIPacket packet1 = new LUCIPacket(messageStr.getBytes(), (short) messageStr.length(), (short) 3, (byte) LSSDPCONST.LUCI_SET);                luciPackets.add(packet1);*/   /* Anyway we have already sent the SendAsyn When Socket is Created So , Dont need to send onemoretime its a Bug*/                // new LUCIControl(mInputNode.getIP()).sendAsynchronousCommandSpecificPlaces();            }else{                LibreLogger.d(this,"In Create Or Update My New Device for the FirstNotification is 0 or CreationTimeMills's Difference is less than 5s for Ipaddress --> " + mInputNode.getIP() +                        "And Name of the Device is " + mInputNode.getFriendlyname());                NettyAndroidClient nettyAndroidClient = LUCIControl.luciSocketMap.get(mInputNode.getIP());                nettyAndroidClient.setLastNotifiedTime(System.currentTimeMillis());                LUCIControl.luciSocketMap.put(mInputNode.getIP(), nettyAndroidClient);            }        }        else{            LibreLogger.d(this,"In Create Or Update My New Device for the LuciSocket is Not " +                    "availabe for the ipddress --> " + mInputNode.getIP() +                    "And Name of the Device is " + mInputNode.getFriendlyname());            /* Socket is Not Avaiable*/            LUCIControl.luciSocketMap.put(mInputNode.getIP(), NettyAndroidClient.getDummyInstance());            LibreLogger.d(this, "Socket Creating for Ip " + mInputNode.getIP() + " as a DummyInstance ");            try {                NettyAndroidClient tcpSocketSendCtr = new NettyAndroidClient(mInputNode.getNodeAddress(), 7777);                LibreLogger.d(this, "Socket Created for Ip " + mInputNode.getIP() + " Printing From NettyAndroidClient Socket  " + tcpSocketSendCtr.getRemotehost());                //if(tcpSocketSendCtr.isSocketCreated())                {                    tcpSocketSendCtr.setLastNotifiedTime(System.currentTimeMillis());                    LUCIControl.luciSocketMap.put(mInputNode.getIP(), tcpSocketSendCtr);                    LUCIControl control = new LUCIControl(mInputNode.getIP());                    control.sendAsynchronousCommandSpecificPlaces();                    LSSDPNodeDB lssdpNodeDB = LSSDPNodeDB.getInstance();                    LSSDPNodes theNodeBasedOnTheIpAddress = lssdpNodeDB.getTheNodeBasedOnTheIpAddress(mInputNode.getIP());                    if (theNodeBasedOnTheIpAddress != null && theNodeBasedOnTheIpAddress.getgCastVerision() != null) {                        // sleep                        try {                            Thread.sleep(250);                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    /*sending asynchronous command*/                       /* Anyway we have already sent the SendAsyn When Socket is Created So , Dont need to send onemoretime its a Bug*/                    // new LUCIControl(mInputNode.getIP()).sendAsynchronousCommandSpecificPlaces();                    LibreLogger.d(this, "Socket Created for Ip 2 " + mInputNode.getIP() + " Printing From NettyAndroidClient Socket  " + tcpSocketSendCtr.getRemotehost());                }            } catch (Exception e1) {                e1.printStackTrace();                LibreLogger.d(this, "Socket creation Failed in EchoServerHandler " + mInputNode.getIP());                LUCIControl.luciSocketMap.remove(mInputNode.getIP());                Log.e("Scan_Netty", "Socket creation not required in  EchoServerHandler" + mInputNode.getIP());            }        }        /* Checking Dupicates Irrespective of Socket is Available or not        * */        if ((mInputNode!=null) && (mInputNode.getIP() !=null) && (mInputNode.getDeviceState()!=null) &&                (!m_scanHandler.findDupicateNode(mInputNode))) {            LibreLogger.d(this, "New Node is Found For the ipAddress " + mInputNode.getIP());            if(!mInputNode.getUSN().isEmpty()) {                BusProvider.getInstance().post(mInputNode);                m_scanHandler.lssdpNodeDB.AddtoDB(mInputNode);                ScanningHandler mScanHandler = ScanningHandler.getInstance();                SceneObject sceneObjec = new SceneObject(" ", "", 0, mInputNode.getIP());                if (!mScanHandler.isIpAvailableInCentralSceneRepo(mInputNode.getIP())) {                    mScanHandler.putSceneObjectToCentralRepo(mInputNode.getIP(), sceneObjec);                }            }else{                LibreLogger.d(this, "USN is Empty " + mInputNode.getIP());            }        }    }    private boolean isChannelToBeRemovedFromTheChannelHandlerMap(ChannelHandlerContext ctx, String mIpAddress) {        if (ctx.getChannel().getId() == LUCIControl.channelHandlerContextMap.get(mIpAddress).getChannel().getId()) {            LibreLogger.d(this, "EchoServerHandler" + "Channel is broken " + mIpAddress + "id as "                            + ctx.getChannel().getId() + "but its  Matched with " +                            LUCIControl.channelHandlerContextMap.get(mIpAddress).getChannel().getId()            );            return true;        } else {            LibreLogger.d(this, "EchoServerHandler" + "Channel is broken " + mIpAddress + "id as "                            + ctx.getChannel().getId() + "but its Not Matched with " +                            LUCIControl.channelHandlerContextMap.get(mIpAddress).getChannel().getId()            );            return false;        }    }    public void RemovingTheCorrespondingSceneMapFromCentralDB(LSSDPNodes mNode){        String mIpAddress = mNode.getIP();        LSSDPNodeDB mNodeDB = LSSDPNodeDB.getInstance();        try {            if(ScanningHandler.getInstance().isIpAvailableInCentralSceneRepo(mIpAddress)) {                boolean status = ScanningHandler.getInstance().removeSceneMapFromCentralRepo(mIpAddress);                LibreLogger.d(this, "Removing the Corresponding SceneMap Fro CentralDB status is " + status+ " For the ip is " + mIpAddress);            }        }catch(Exception e){            LibreLogger.d(this, "Removing the Corresponding SceneMap Fro CentralDB status" + "Removal Exception ");        }        mNodeDB.clearNode(mIpAddress);    }}