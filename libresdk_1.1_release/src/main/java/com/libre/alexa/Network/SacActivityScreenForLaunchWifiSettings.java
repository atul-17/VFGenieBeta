package com.libre.alexa.Network;import android.Manifest;import android.annotation.SuppressLint;import android.annotation.TargetApi;import android.app.AlertDialog;import android.app.ProgressDialog;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.content.IntentSender;import android.content.pm.PackageManager;import android.location.Location;import android.location.LocationManager;import android.net.Uri;import android.net.wifi.WifiInfo;import android.net.wifi.WifiManager;import android.os.Build;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.provider.Settings;import androidx.annotation.NonNull;import androidx.core.app.ActivityCompat;import android.text.Html;import android.util.Log;import android.view.Gravity;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.ImageButton;import android.widget.TextView;import android.widget.Toast;import com.google.android.gms.common.api.ApiException;import com.google.android.gms.common.api.ResolvableApiException;import com.google.android.gms.location.FusedLocationProviderClient;import com.google.android.gms.location.LocationCallback;import com.google.android.gms.location.LocationRequest;import com.google.android.gms.location.LocationResult;import com.google.android.gms.location.LocationServices;import com.google.android.gms.location.LocationSettingsRequest;import com.google.android.gms.location.LocationSettingsResponse;import com.google.android.gms.location.LocationSettingsStatusCodes;import com.google.android.gms.location.SettingsClient;import com.google.android.gms.tasks.OnFailureListener;import com.google.android.gms.tasks.OnSuccessListener;import com.karumi.dexter.Dexter;import com.karumi.dexter.PermissionToken;import com.karumi.dexter.listener.PermissionDeniedResponse;import com.karumi.dexter.listener.PermissionGrantedResponse;import com.karumi.dexter.listener.PermissionRequest;import com.karumi.dexter.listener.single.PermissionListener;import com.libre.alexa.BuildConfig;import com.libre.alexa.DeviceDiscoveryActivity;import com.libre.alexa.LibreApplication;import com.libre.alexa.R;import com.libre.alexa.Scanning.Constants;import com.libre.alexa.luci.Utils;import com.libre.alexa.serviceinterface.LSDeviceClient;import com.libre.alexa.util.LibreLogger;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.net.NetworkInterface;import java.text.DateFormat;import java.util.Date;import java.util.Iterator;import java.util.Map;import java.util.Set;import java.util.TreeMap;import retrofit.Callback;import retrofit.RetrofitError;import retrofit.client.Response;public class SacActivityScreenForLaunchWifiSettings extends DeviceDiscoveryActivity {    Button mOpenSettings;    Button mNextButton;    private boolean mDontAvoidOnResume = true;    private ImageButton m_back;    protected AlertDialog alert, launchGcastAppAlert;    private String mCurrentSsidItGotConnected = LibreApplication.activeSSID;    final private int PERMISSION_DEVICE_DISCOVERY = 100;    static final String REQ_TAG = "SacActivityScreenForLaunchWifiSettings";    // fastest updates interval - 5 sec    // location updates will be received if another app is requesting the locations    // than your app can handle    private static final long FASTEST_UPDATE_INTERVAL_IN_MILLISECONDS = 5000;    private static final int REQUEST_CHECK_SETTINGS = 100;    String defaultLocale;    // location last updated time    private String mLastUpdateTime;    private AlertDialog alertShowDialog;    // location related apis    private FusedLocationProviderClient mFusedLocationClient;    private SettingsClient mSettingsClient;    private LocationRequest mLocationRequest;    private LocationSettingsRequest mLocationSettingsRequest;    private LocationCallback mLocationCallback;    private Location mCurrentLocation;    private Boolean mRequestingLocationUpdates;    Handler handler = new Handler() {        @Override        public void handleMessage(Message msg) {            switch (msg.what) {                case Constants.GETTING_SCAN_RESULTS:                    closeLoader();                    somethingWentWrong(SacActivityScreenForLaunchWifiSettings.this);                    restartApp(SacActivityScreenForLaunchWifiSettings.this);                    break;            }        }    };    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_sac_activity_screen_for_launch_wifi_settings);        // initialize the necessary libraries        init();        // setBluetooth(true);        // restore the values from saved instance state        restoreValuesFromBundle(savedInstanceState);        mOpenSettings = (Button) findViewById(R.id.btnCallingWifiSettings);        mOpenSettings.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                disableNetworkChangeCallBack();                disableNetworkOffCallBack();                WifiConnection.getInstance().mPreviousSSID = getconnectedSSIDname(SacActivityScreenForLaunchWifiSettings.this);                LibreApplication.activeSSID = WifiConnection.getInstance().mPreviousSSID;                mDontAvoidOnResume = false;                /* Giving User Access to Connect to Specific WAC_SSIDXXXX*///                startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));                Intent intent = new Intent(Settings.ACTION_WIFI_SETTINGS);                intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);                startActivityForResult(intent, 1234);            }        });        mNextButton = (Button) findViewById(R.id.btnNext);        mNextButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                String mPhoneIpaddresss = phoneIpAddress();                String mSsidGotConnected = getconnectedSSIDname(SacActivityScreenForLaunchWifiSettings.this);                if (mSsidGotConnected != null) {                    if (mSsidGotConnected.endsWith(".d")) {                        callGcastAppBasedOnIpAddress();                        return;                    }                }                if (getconnectedSSIDname(SacActivityScreenForLaunchWifiSettings.this) != null) {                    if (getconnectedSSIDname(SacActivityScreenForLaunchWifiSettings.this).contains(Constants.WAC_SSID) ) {                    /*if(mPhoneIpaddresss!=null && mPhoneIpaddresss.contains("192.168.255.")) {                        callGcastAppBasedOnIpAddress();                    }else*/                        {                            String mSACDeviceConnectedName = getconnectedSSIDname(SacActivityScreenForLaunchWifiSettings.this);                            showLoader("");                            handler.sendEmptyMessageDelayed(Constants.GETTING_SCAN_RESULTS, 15000);                            if (mDeviceName == null) {                                getDeviceName(mSACDeviceConnectedName, "");                            } else {                                getScanResult();                            }                        }                    } else {                        showAlertDialogForClickingWrongNetwork();                    }                }            }        });    }    private void init() {        mFusedLocationClient = LocationServices.getFusedLocationProviderClient(this);        mSettingsClient = LocationServices.getSettingsClient(this);        mLocationCallback = new LocationCallback() {            @Override            public void onLocationResult(LocationResult locationResult) {                super.onLocationResult(locationResult);                // location is received                mCurrentLocation = locationResult.getLastLocation();                mLastUpdateTime = DateFormat.getTimeInstance().format(new Date());                // updateLocationUI();            }        };        mRequestingLocationUpdates = false;        mLocationRequest = new LocationRequest();//        mLocationRequest.setInterval(UPDATE_INTERVAL_IN_MILLISECONDS);//        mLocationRequest.setFastestInterval(FASTEST_UPDATE_INTERVAL_IN_MILLISECONDS);//        mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);        mLocationRequest.setPriority(LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY);        mLocationRequest.setSmallestDisplacement(30); //higher priority        //setInterval as above 1 mins.        mLocationRequest.setInterval(60000); // Update location every 1 minute        mLocationRequest.setFastestInterval(10000);        LocationSettingsRequest.Builder builder = new LocationSettingsRequest.Builder();        builder.addLocationRequest(mLocationRequest);        mLocationSettingsRequest = builder.build();    }    @Override    public void onSaveInstanceState(Bundle outState) {        super.onSaveInstanceState(outState);        outState.putBoolean("is_requesting_updates", mRequestingLocationUpdates);        outState.putParcelable("last_known_location", mCurrentLocation);        outState.putString("last_updated_on", mLastUpdateTime);    }    private boolean mGcastAppCalled = false;    private void mAfterGcastAppCalled() {        if (mGcastAppCalled) {            String mSsidGotConnected = getconnectedSSIDname(SacActivityScreenForLaunchWifiSettings.this);            if (mSsidGotConnected.endsWith(".d")) {                callGcastAppBasedOnIpAddress();            } else {                AlertDialog.Builder builder = new AlertDialog.Builder(SacActivityScreenForLaunchWifiSettings.this);                alert = null;                builder.setMessage(getResources().getString(R.string.title_error_connection) + "( " + mSsidGotConnected + ")" +                        " \n" + getString(R.string.networkChangeRestartApp))                        .setCancelable(false)                        .setPositiveButton(getString(R.string.ok), new DialogInterface.OnClickListener() {                            public void onClick(DialogInterface dialog, int id) {                                mCurrentSsidItGotConnected = "";                                restartApp(SacActivityScreenForLaunchWifiSettings.this);                                alert.dismiss();                            }                        });                if (alert == null) {                    alert = builder.show();                    TextView messageView = (TextView) alert.findViewById(android.R.id.message);                    messageView.setGravity(Gravity.CENTER);                }                alert.show();            }        }    }    @Override    protected void onDestroy() {        super.onDestroy();        handler.removeMessages(Constants.GETTING_SCAN_RESULTS);        closeLoader();    }    @Override    protected void onActivityResult(int requestCode, int resultCode, Intent data) {        if (requestCode == 1234) {            LibreLogger.d(this, "came back from wifi list");            LibreApplication application = (LibreApplication) getApplication();            application.initiateServices();            mNextButton.performClick();            setScanCount(0);        } else if (requestCode == 1235 &&                resultCode == RESULT_OK) {            mGcastAppCalled = true;        }    }    ProgressDialog mProgressDialog;    public void showLoader(final String msg) {        runOnUiThread(new Runnable() {            @Override            public void run() {                Log.d("ShowingLoader", "Showing loader method");                if (mProgressDialog == null) {                    mProgressDialog = ProgressDialog.show(SacActivityScreenForLaunchWifiSettings.this, getResources().getString(R.string.notice), getResources().getString(R.string.retrieving) + "...", true, true, null);                }                mProgressDialog.setCancelable(false);                if (!mProgressDialog.isShowing()) {                    if (!(SacActivityScreenForLaunchWifiSettings.this.isFinishing())) {                        mProgressDialog = ProgressDialog.show(SacActivityScreenForLaunchWifiSettings.this, getResources().getString(R.string.notice), getResources().getString(R.string.retrieving) + "...", true, true, null);                    }                }            }        });    }    public void closeLoader() {        runOnUiThread(new Runnable() {            @Override            public void run() {                if (mProgressDialog != null && mProgressDialog.isShowing()) {                    if (!(SacActivityScreenForLaunchWifiSettings.this.isFinishing())) {                        mProgressDialog.setCancelable(false);                        mProgressDialog.dismiss();                        mProgressDialog.cancel();                    }                }            }        });    }    /**     * Restoring values from saved instance state     */    private void restoreValuesFromBundle(Bundle savedInstanceState) {        if (savedInstanceState != null) {            if (savedInstanceState.containsKey("is_requesting_updates")) {                mRequestingLocationUpdates = savedInstanceState.getBoolean("is_requesting_updates");            }            if (savedInstanceState.containsKey("last_known_location")) {                mCurrentLocation = savedInstanceState.getParcelable("last_known_location");            }            if (savedInstanceState.containsKey("last_updated_on")) {                mLastUpdateTime = savedInstanceState.getString("last_updated_on");            }        }        // updateLocationUI();    }    public void showAlertDialogForClickingWrongNetwork() {        if (!SacActivityScreenForLaunchWifiSettings.this.isFinishing()) {            alertShowDialog = null;            AlertDialog.Builder builder = new AlertDialog.Builder(SacActivityScreenForLaunchWifiSettings.this);            String Message = getResources().getString(R.string.title_error_sac_message) + "\n(" + Constants.WAC_SSID + "XXXXXX)";            builder.setMessage(Message)                    .setCancelable(false)                    .setPositiveButton(getString(R.string.ok), new DialogInterface.OnClickListener() {                        public void onClick(DialogInterface dialog, int id) {                            alertShowDialog.dismiss();                        }                    });            if (alertShowDialog == null) {                alertShowDialog = builder.show();            }            alertShowDialog.show();        }    }    @TargetApi(Build.VERSION_CODES.M)    public void request() {        if (!shouldShowRequestPermissionRationale(Manifest.permission.ACCESS_COARSE_LOCATION)) {            // user checked Never Ask again            LibreLogger.d(this, "permit ACCESS_COARSE_LOCATION Denied for ever");            // show dialog            AlertDialog.Builder requestPermission = new AlertDialog.Builder(SacActivityScreenForLaunchWifiSettings.this);            requestPermission.setTitle(getString(R.string.permitNotAvailable))                    .setMessage(getString(R.string.enableLocationPermit))                    .setPositiveButton(getString(R.string.gotoSettings), new DialogInterface.OnClickListener() {                        @Override                        public void onClick(DialogInterface dialog, int which) {                            //navigate to settings                            alert.dismiss();                            Intent intent = new Intent();                            intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);                            Uri uri = Uri.fromParts("package", getPackageName(), null);                            intent.setData(uri);                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);                            intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);                            intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);                            startActivity(intent);                        }                    })                    .setCancelable(false);            if (alert == null) {                alert = requestPermission.create();            }            if (alert != null && !alert.isShowing())                alert.show();            return;        }        requestPermissions(new String[]{Manifest.permission.ACCESS_COARSE_LOCATION}, PERMISSION_DEVICE_DISCOVERY);        return;    }    public void afterPermission() {//        mAfterGcastAppCalled();        setScanCount(0);        if(mDontAvoidOnResume) {            mCurrentSsidItGotConnected = getconnectedSSIDname(SacActivityScreenForLaunchWifiSettings.this);            if (!mCurrentSsidItGotConnected.equalsIgnoreCase(LibreApplication.activeSSID) &&                    !mCurrentSsidItGotConnected.contains(Constants.WAC_SSID)                    && !mCurrentSsidItGotConnected.endsWith(".d")) {//                if (!SacActivityScreenForLaunchWifiSettings.this.isFinishing()) {//                    AlertDialog.Builder builder = new AlertDialog.Builder(SacActivityScreenForLaunchWifiSettings.this);//                    alert = null;//                    builder.setMessage(getResources().getString(R.string.title_error_connection) + "( " + mCurrentSsidItGotConnected + ")" +//                            " \n" + getString(R.string.networkChangeRestartApp))//                            .setCancelable(false)//                            .setPositiveButton(getString(R.string.ok), new DialogInterface.OnClickListener() {//                                public void onClick(DialogInterface dialog, int id) {////                                    mCurrentSsidItGotConnected = "";//                                    restartApp(SacActivityScreenForLaunchWifiSettings.this);//                                    alert.dismiss();//                                }//                            });//                    if (alert == null) {//                        alert = builder.show();//                        TextView messageView = (TextView) alert.findViewById(android.R.id.message);//                        messageView.setGravity(Gravity.CENTER);//                    }////                    alert.show();////                }            } else if (getconnectedSSIDname(SacActivityScreenForLaunchWifiSettings.this).contains(Constants.WAC_SSID)                    || mCurrentSsidItGotConnected.endsWith(".d")) {                LibreLogger.d(this, "suma in sac is connected to WAC_SSID, so going to ssid_configuration");                mNextButton.performClick();                LibreLogger.d(this,"suma in sac something went wrong ssid configuration screen");            }        }    }    @TargetApi(Build.VERSION_CODES.M)    private void locationPermission() {        if (checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED) {            LibreLogger.d(this, "permit ACCESS_COARSE_LOCATION Granted");            afterPermission();            return;        } else {            LibreLogger.d(this, "permit ACCESS_COARSE_LOCATION not Granted");            // request is denied by the user. so requesting            request();        }    }    @Override    protected void onResume() {        super.onResume();        if (checkPermissions()&& isLocationEnabled())        {            afterPermission();            LibreLogger.d(this,"fused location api suma in onresume1");        }        else        {            LibreLogger.d(this,"fused location api suma in onresume2");            Dexter.withActivity(SacActivityScreenForLaunchWifiSettings.this)                    .withPermission(Manifest.permission.ACCESS_FINE_LOCATION)                    .withListener(new PermissionListener() {                        @Override                        public void onPermissionGranted(PermissionGrantedResponse response) {                            mRequestingLocationUpdates = true;                            startLocationUpdates();                        }                        @Override                        public void onPermissionDenied(PermissionDeniedResponse response) {                            if (response.isPermanentlyDenied()) {                                // open device settings when the permission is                                // denied permanently                                openSettings();                            }                        }                        @Override                        public void onPermissionRationaleShouldBeShown(PermissionRequest permission, PermissionToken token) {                            token.continuePermissionRequest();                        }                    }).check();        }    }    private void openSettings() {        Intent intent = new Intent();        intent.setAction(                Settings.ACTION_APPLICATION_DETAILS_SETTINGS);        Uri uri = Uri.fromParts("package",                BuildConfig.LIBRARY_PACKAGE_NAME, null);        intent.setData(uri);        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);        startActivity(intent);    }    /**     * Starting location updates     * Check whether location settings are satisfied and then     * location updates will be requested     */    private void startLocationUpdates() {        mSettingsClient                .checkLocationSettings(mLocationSettingsRequest)                .addOnSuccessListener(this, new OnSuccessListener<LocationSettingsResponse>() {                    @SuppressLint("MissingPermission")                    @Override                    public void onSuccess(LocationSettingsResponse locationSettingsResponse) {                        //Log.i(TAG, "All location settings are satisfied.");//                        Toast.makeText(getApplicationContext(), "Started location updates!", Toast.LENGTH_SHORT).show();                        //noinspection MissingPermission                        mFusedLocationClient.requestLocationUpdates(mLocationRequest,                                mLocationCallback, Looper.myLooper());                        // updateLocationUI();                    }                })                .addOnFailureListener(this, new OnFailureListener() {                    @Override                    public void onFailure(@NonNull Exception e) {                        int statusCode = ((ApiException) e).getStatusCode();                        switch (statusCode) {                            case LocationSettingsStatusCodes.RESOLUTION_REQUIRED:                                // Log.i("LSSDP", "Location settings are not satisfied. Attempting to upgrade " +                                // "location settings ");                                try {                                    // Show the dialog by calling startResolutionForResult(), and check the                                    // result in onActivityResult().                                    ResolvableApiException rae = (ResolvableApiException) e;                                    rae.startResolutionForResult(SacActivityScreenForLaunchWifiSettings.this, REQUEST_CHECK_SETTINGS);                                } catch (IntentSender.SendIntentException sie) {                                    // Log.i(TAG, "PendingIntent unable to execute request.");                                }                                break;                            case LocationSettingsStatusCodes.SETTINGS_CHANGE_UNAVAILABLE:                                String errorMessage = "Location settings are inadequate, and cannot be " +                                        "fixed here. Fix in Settings.";                                //  Log.e(TAG, errorMessage);                                Toast.makeText(SacActivityScreenForLaunchWifiSettings.this, errorMessage, Toast.LENGTH_LONG).show();                        }                    }                });    }    private boolean checkPermissions() {        int permissionState = ActivityCompat.checkSelfPermission(this,                Manifest.permission.ACCESS_FINE_LOCATION);        return permissionState == PackageManager.PERMISSION_GRANTED;    }    private void afterPermit() {        if (!isLocationEnabled()) {            LibreLogger.d(this, "Location is disabled");            askToEnableLocationService();        }    }    public boolean isLocationEnabled() {        LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);        if (!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) && !locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)) {            //All location services are disabled            return false;        } else {            return true;        }    }    private void askToEnableLocationService() {        AlertDialog.Builder builder = new AlertDialog.Builder(SacActivityScreenForLaunchWifiSettings.this);        builder.setTitle(getResources().getString(R.string.locationServicesIsOff))                .setMessage(getResources().getString(R.string.enableLocationPermit))                .setPositiveButton(getResources().getString(R.string.gotoSettings), new DialogInterface.OnClickListener() {                    @Override                    public void onClick(DialogInterface dialogInterface, int i) {                        dialogInterface.cancel();                        turnGPSOn();                    }                });        builder.create();        builder.show();    }    @TargetApi(Build.VERSION_CODES.M)    private void askPermit() {        requestPermissions(new String[]{Manifest.permission.ACCESS_COARSE_LOCATION},                Constants.PERMISSIONS_REQUEST_CODE_ACCESS_COARSE_LOCATION);    }    @TargetApi(Build.VERSION_CODES.M)    @Override    public void onRequestPermissionsResult(int requestCode, String[] permissions,                                           int[] grantResults) {        if (requestCode == Constants.PERMISSIONS_REQUEST_CODE_ACCESS_COARSE_LOCATION                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {            // Do something with granted permission            //afterPermit();        } else if (requestCode == Constants.PERMISSIONS_REQUEST_CODE_ACCESS_COARSE_LOCATION                && grantResults[0] == PackageManager.PERMISSION_DENIED) {            if (!shouldShowRequestPermissionRationale(Manifest.permission.ACCESS_COARSE_LOCATION)) {                // user checked Never Ask again                Log.d("asking permit", "permit ACCESS_COARSE_LOCATION Denied for ever");                // show dialog                AlertDialog.Builder requestPermission = new AlertDialog.Builder(SacActivityScreenForLaunchWifiSettings.this);                requestPermission.setTitle(getString(R.string.permitNotAvailable))                        .setMessage(getString(R.string.permissionMsg))                        .setPositiveButton(getString(R.string.gotoSettings), new DialogInterface.OnClickListener() {                            @Override                            public void onClick(DialogInterface dialog, int which) {                                //navigate to settings                                dialog.dismiss();                                Intent intent = new Intent();                                intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);                                Uri uri = Uri.fromParts("package", getPackageName(), null);                                intent.setData(uri);                                startActivity(intent);                            }                        })                        .setCancelable(false);                if (alert == null) {                    alert = requestPermission.create();                }                if (alert != null && !alert.isShowing())                    alert.show();            }        }    }    private void turnGPSOn() {        Intent intent = new Intent(                Settings.ACTION_LOCATION_SOURCE_SETTINGS);        startActivity(intent);    }    public boolean isLocationPermissionEnabled() {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            if (checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED) {                LibreLogger.d(this, "checking permission ACCESS_COARSE_LOCATION permission is enabled");                return true;            }        } else {            //Android OS version is less than M. So permission is always enabled            LibreLogger.d(this, "checking permission OS is less than M, ACCESS_COARSE_LOCATION permission is enabled");            return true;        }        LibreLogger.d(this, "checking permission ACCESS_COARSE_LOCATION permission is not enabled");        return false;    }    public String getconnectedSSIDname(Context mContext) {        WifiManager wifiManager;        wifiManager = (WifiManager) mContext.getApplicationContext().getSystemService(Context.WIFI_SERVICE);        WifiInfo wifiInfo = wifiManager.getConnectionInfo();        String ssid = wifiInfo.getSSID();        LibreLogger.d(this, "suma in sac getconnectedSSIDname wifiInfo = " + wifiInfo.toString());        if (ssid.startsWith("\"") && ssid.endsWith("\"")) {            ssid = ssid.substring(1, ssid.length() - 1);        }        return ssid;    }    private TreeMap<String, String> mUnSortedHashmap = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);    private void SortTheList(TreeMap<String, String> mUnMap) {        Map<String, String> treeMap = new TreeMap<String, String>(mUnMap);        Set s = treeMap.entrySet();        Iterator it = s.iterator();        while (it.hasNext()) {            Map.Entry entry = (Map.Entry) it.next();            String key = (String) entry.getKey();            String value = (String) entry.getValue();            System.out.println(key + " => " + value);            WifiConnection.getInstance().putWifiScanResultSecurity(key, value);        }    }    private void parseJson(String mJson) {        try {            JSONObject jsonRootObject = new JSONObject(mJson);            //Get the instance of JSONArray that contains JSONObjects            JSONArray jsonArray = jsonRootObject.optJSONArray("Items");            //Iterate the jsonArray and print the info of JSONObjects            for (int i = 0; i < jsonArray.length(); i++) {                JSONObject jsonObject = jsonArray.getJSONObject(i);                String SSIDName = jsonObject.optString("SSID").toString();                String Security = jsonObject.optString("Security").toString();                String mSsidNameHtml = Html.fromHtml(SSIDName).toString();                String mSecurityHtml = Html.fromHtml(Security).toString();                LibreLogger.d(this, "SSIDNAMe" + SSIDName + " :: Security" + Security);                if (Security != null && (Security.contains("WEP") || Security.contains("wep"))) {                    Log.d("SecurityIssue", "parseJson() ignoring WEP");                    continue;                }                mUnSortedHashmap.put(mSsidNameHtml, mSecurityHtml);            }            SortTheList(mUnSortedHashmap);        } catch (JSONException e) {            e.printStackTrace();        }    }    private int scanCount = -1;    private int scanDeviceNameCount = -1;    private int MAX_SCAN_COUNT = 6;    private int MAX_SCAN_DEVICE_NAME_COUNT = 6;    private void getScanResult() {        GetScanResults getScanResults = new GetScanResults(this, new WifiScanlistListener() {            @Override            public void success(Object response) {                LibreLogger.d(this,"suma in sac response for scan result is "+response);                /* retry if the ScanResult is null*/                if(response==null) {                    mNextButton.performClick();                    return;                }                //JSONObject mJsonObject = new JSONObject(mScanResult.toString());                parseJson(response.toString());                Intent ssid = new Intent(SacActivityScreenForLaunchWifiSettings.this, ssid_configuration.class).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);                String mSsid = getconnectedSSIDname(SacActivityScreenForLaunchWifiSettings.this);                if (mDeviceName!=null) {                    WifiConnection.getInstance().putssidDeviceNameSAC(mSsid, mDeviceName);                    Log.e("SACDeviceName---", mDeviceName);                    ssid.putExtra("DeviceIP", "192.168.43.1");                    ssid.putExtra("activity", "SacListActivity");                    ssid.putExtra("DeviceSSID", mSsid);                    startActivity(ssid);                    finish();                } else {                    rescanWifi();                    LibreLogger.d(this,"suma in sac something went wrong scan result");                    return;                }            }            @Override            public void failure(Exception e) {                rescanWifi();                LibreLogger.d(this,"suma in sac getting scan results failed "+e.getMessage());            }        });        getScanResults.execute();    }    public void rescanWifi() {        if (getScanCount() == MAX_SCAN_COUNT) {            handler.removeMessages(Constants.GETTING_SCAN_RESULTS);            handler.sendEmptyMessageDelayed(Constants.GETTING_SCAN_RESULTS, 15000);            setScanCount(0);            somethingWentWrong(SacActivityScreenForLaunchWifiSettings.this);            return;        }        incrementScanCount();        LibreApplication application = (LibreApplication) getApplication();        application.initiateServices();        runOnUiThread(new Runnable() {            @Override            public void run() {                mNextButton.performClick();            }        });    }    @Override    public void onBackPressed() {        super.onBackPressed();        /*Intent intent = new Intent(SacActivityScreenForLaunchWifiSettings.this, NewSacActivity.class).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);        startActivity(intent);        finish();*/        intentToHome(SacActivityScreenForLaunchWifiSettings.this);    }    private void getDeviceName(final String netId, String ss) {        LSDeviceClient lsDeviceClient = new LSDeviceClient();        LSDeviceClient.DeviceNameService deviceNameService = lsDeviceClient.getDeviceNameService();        deviceNameService.getSacDeviceName(new Callback<String>() {            @Override            public void success(String deviceName, Response response) {                mDeviceName = Html.fromHtml(deviceName).toString();                LibreLogger.d(this, "Device name when sac " + mDeviceName + ", seeking scan result");                getScanResult();                setScanDeviceNameCount(0);            }            @Override            public void failure(RetrofitError error) {                LibreLogger.d(this, "re asking device name , then asking scan result");                reAskDeviceName();            }        });    }    private void reAskDeviceName() {        LibreLogger.d(this, "re asking device name 2, then asking scan result");        if (getScanDeviceNameCount() == MAX_SCAN_DEVICE_NAME_COUNT) {            setScanDeviceNameCount(0);            mDeviceName = "";            getScanResult();        }        WifiManager mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);        try {            //check if SAC is still alive in wifi list            mWifiManager.startScan();        } catch (Exception e) {        }        incrementScanDeviceNameCount();        LibreApplication application = (LibreApplication) getApplication();        application.initiateServices();        runOnUiThread(new Runnable() {            @Override            public void run() {                mNextButton.performClick();            }        });    }    public String mDeviceName;    @Override    public boolean onCreateOptionsMenu(Menu menu) {        // Inflate the menu; this adds items to the action bar if it is present.        getMenuInflater().inflate(R.menu.menu_sac_activity_screen_for_launch_wifi_settings, menu);        return false;    }    @Override    public boolean onOptionsItemSelected(MenuItem item) {        // Handle action bar item clicks here. The action bar will        // automatically handle clicks on the Home/Up button, so long        // as you specify a parent activity in AndroidManifest.xml.        int id = item.getItemId();        //noinspection SimplifiableIfStatement        if (id == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(item);    }    public void callGcastAppBasedOnIpAddress() {        AlertDialog finalAlert = null;        if (!SacActivityScreenForLaunchWifiSettings.this.isFinishing()) {            launchGcastAppAlert = null;            AlertDialog.Builder builder = new AlertDialog.Builder(SacActivityScreenForLaunchWifiSettings.this);            String Message = getResources().getString(R.string.gCastAppLaunch);            builder.setMessage(Message)                    .setCancelable(false)                    .setPositiveButton("Launch", new DialogInterface.OnClickListener() {                        public void onClick(DialogInterface dialog, int id) {                            launchGcastAppAlert.dismiss();                            launchTheApp("com.google.android.apps.chromecast.app");                        }                    });            if (launchGcastAppAlert == null) {                launchGcastAppAlert = builder.show();                TextView messageView = (TextView) launchGcastAppAlert.findViewById(android.R.id.message);                messageView.setGravity(Gravity.CENTER);            }            launchGcastAppAlert.show();        }    }    public void launchTheApp(String appPackageName) {        Intent intent = getApplicationContext().getPackageManager().getLaunchIntentForPackage(appPackageName);        mDontAvoidOnResume = false;        mGcastAppCalled = true;        try {            if (launchGcastAppAlert != null && launchGcastAppAlert.isShowing())                launchGcastAppAlert.dismiss();        } catch (Exception e) {        }        if (intent != null) {            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);            startActivity(intent);        } else {            redirectingToPlayStore(intent, appPackageName);        }    }    public void redirectingToPlayStore(Intent intent, String appPackageName) {        try {            intent = new Intent(Intent.ACTION_VIEW);            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);            intent.setData(Uri.parse("market://details?id=" + appPackageName));            startActivity(intent);        } catch (android.content.ActivityNotFoundException anfe) {            intent = new Intent(Intent.ACTION_VIEW);            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);            intent.setData(Uri.parse("http://play.google.com/store/apps/details?id=" + appPackageName));            startActivity(intent);        }    }    public String phoneIpAddress() {        NetworkInterface mNetIf = Utils.getActiveNetworkInterface();        if (mNetIf != null) {            if (Utils.getLocalV4Address(mNetIf) != null)                return Utils.getLocalV4Address(mNetIf).getHostAddress();        }        return null;    }    public int getScanCount() {        return scanCount;    }    public void incrementScanCount() {        int i = getScanCount();        i++;        setScanCount(i);    }    public void incrementScanDeviceNameCount() {        int i = getScanDeviceNameCount();        i++;        setScanDeviceNameCount(i);    }    public void setScanCount(int scanCount) {        this.scanCount = scanCount;    }    public int getScanDeviceNameCount() {        return scanDeviceNameCount;    }    public void setScanDeviceNameCount(int scanDeviceNameCount) {        this.scanDeviceNameCount = scanDeviceNameCount;    }}